\documentclass[onecolumn, draftclsnofoot,10pt, compsoc]{IEEEtran}
\usepackage{graphicx}
\usepackage{url}
\usepackage{setspace}
\usepackage{hyperref}
\def\name{Daniel Schroeder}

%pull in the necessary preamble matter for pygments output
\input{pygments.tex}

%% The following metadata will show up in the PDF properties
\hypersetup{
  colorlinks = true,
  urlcolor = red,
  linkcolor = red,
  citecolor = black,
  pdfauthor = {\name},
  pdfkeywords = {CS461 ``Senior Capstone'' Technology Review},
  pdftitle = {CS461 ``Senior Capstone'' Technology Review},
  pdfsubject = {CS461 ``Senior Capstone'' Technology Review},
  pdfpagemode = UseNone
}
\usepackage{listings}
\usepackage{color}
\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}
\usepackage[margin=0.75in]{geometry}
\geometry{textheight=9.5in, textwidth=7in}
\lstdefinelanguage{JavaScript}{
    keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
    keywordstyle=\color{blue}\bfseries,
    ndkeywords={class, export, boolean, throw, implements, import, this},
    ndkeywordstyle=\color{darkgray}\bfseries,
    identifierstyle=\color{black},
    sensitive=false,
    comment=[l]{//},
    morecomment=[s]{/*}{*/},
    commentstyle=\color{purple}\ttfamily,
    stringstyle=\color{red}\ttfamily,
    morestring=[b]',
    morestring=[b]"
  }
  \lstset{
    language=JavaScript,
    backgroundcolor=\color{lightgray},
    extendedchars=true,
    basicstyle=\footnotesize\ttfamily,
    linewidth=7in,
    xleftmargin=.25in,
    showstringspaces=false,
    showspaces=false,
    numbers=left,
    numberstyle=\footnotesize,
    numbersep=9pt,
    tabsize=2,
    breaklines=true,
    showtabs=false,
    captionpos=b
 }

% 1. Fill in these details
\def \CapstoneTeamName{		The Dream Team}
\def \CapstoneTeamNumber{		57}
\def \GroupMemberOne{			Daniel Schroeder}
\def \GroupMemberTwo{			Aubrey Thenell}
\def \GroupMemberThree{			Parker Bruni}
\def \CapstoneProjectName{		A Scalable Web Application Framework for Monitoring Energy Usage on Campus  }
\def \CapstoneSponsorCompany{	Oregon State Office of Sustainability}
\def \CapstoneSponsorPerson{		Jack Woods}

% 2. Uncomment the appropriate line below so that the document type works
\def \DocType{		%Problem Statement
        %Requirements Document
        Technology Review
        %Design Document
        %Progress Report
        }
    
\newcommand{\NameSigPair}[1]{\par
\makebox[2.75in][r]{#1} \hfil 	\makebox[3.25in]{\makebox[2.25in]{\hrulefill} \hfill		\makebox[.75in]{\hrulefill}}
\par\vspace{-12pt} \textit{\tiny\noindent
\makebox[2.75in]{} \hfil		\makebox[3.25in]{\makebox[2.25in][r]{Signature} \hfill	\makebox[.75in][r]{Date}}}}
% 3. If the document is not to be signed, uncomment the RENEWcommand below
%\renewcommand{\NameSigPair}[1]{#1}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title{\textbf{Scalable Web Application Framework for Monitoring Energy Usage on Campus} \linebreak \LARGE{Group 57} }
\author{Daniel Schroeder}
\date{\today}

\begin{document}
\maketitle
%\vspace{2cm}
\vfill
\noindent \textbf{Abstract} \\
            \indent 
            Data visualization is an important technique for analyzing data trends and identifying problems that may not have been apparent. This document outlines our plan to create a web application which will gather energy data from data aquisition servers and create information management dashboards. Our application will allow users to generate charts and graphs to see energy use over time, compare energy usage across multiple buildings, and create collections of different visualizations.
            
            

\newpage
\pagenumbering{arabic}
\tableofcontents
% 7. uncomment this (if applicable). Consider adding a page break.
%\listoffigures
%\listoftables
\clearpage

% 8. now you write!
\section{Introduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%% Visualization Frameworks %%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Visualization Frameworks}
Our web application will provide near-real time data visualizations for energy consumption on campus buildings. This application will need to dynamically create charts and graphs based on energy data from the database. A key to choosing a visualization library will be to find one that can be dynmaically created and changed as new data is received from the data acquisition servers, and the ability to create chart templates that can be reused on multiple pages with different input parameters. 

\subsection{D3.js}
%https://www.dashingd3js.com/d3-resources/d3-and-angular
\textit{Repository Commits: 4,104}\\  
\textit{Contributors: 120}\\
D3.js is a clunky, massive library that makes use of SVG elements in webpages to append charts and graphics to the DOM. It is extremely well documented and widely used. D3 has a high learning curve for beginners to take head-on, but has a wide array of different visualizations and customization.\\
\textbf{Pros}
\begin{itemize}
\item A lightwight, versatile javascript library that creates SVG elements within web pages and appends them to DOM elements. 
\item Makes use of javascript functions and DOM controlling functionality to dynamically change the content of the page. 
\item Provides a lot of variety and ability to customize graphics.
\item Widely used and there is a lot of documentation and resources available to assist the learning and development processes.
\end{itemize}
\textbf{Cons}
\begin{itemize}
\item D3 is essentially an API to to manipulate SVG, it is not a charting library in of itself.
\item You cannot easily pass a dataset into a specified chart type like other libraries.
\item Considered to be ``code-heavy'' and difficult to jump right into as a novice user.
\item Angular and D3 both attempt to control the DOM and so you have to find a way to make the two work together which is counterintuitive to both framework's APIs. 
\end{itemize}
\subsection{Vis.js}
\textit{Repository Commits: 3,165}\\
\textit{Contributors: 137}\\
Vis.js is a lightweight charting library that allows users to create clean charts from dynamic datasets. It is responsive and allows for interaction with the data on the page. Vis.js is praised for it's network chart capabilities but is limited in the number of different modules you can create.\\
\textbf{Pros}
\begin{itemize}
\item Easy to use and less of a learning curve than D3.
\item Allows for interaction and minpulation of data on the chart.
\item Able to handle large amounts of dynamic data.
\item Really clean and nice looking graphics.
\end{itemize}
\textbf{Cons}
\begin{itemize}
\item Limited amount of possible chart types.
\item Does not have built in heat map.
\end{itemize}
\subsection{Chart.js}
\textit{Repository Commits: 2,465}\\ 
\textit{Contributors: 236}\\
Chart js is a very lightweight library that provides 6 chart types and fully responsive designs. ChartJS is well documented and easy to use, but lacks in variety.\\
\textbf{Pros}
\begin{itemize}
\item Uses HTML5 canvas element.
\item Allows for easy creating based on chart type specification.
\item Library provides Line Charts, Bar Charts, Radar Charts, Pie Charts, Polar Area Charts, and Doughnut Charts.
\item Very responsive charts based on screen width.
\item Simple API, easy to use.
\end{itemize}
\textbf{Cons}
\begin{itemize}
\item Limited amount of possible chart types.
\item Does not have built in heat map.
\end{itemize}
\subsection{Conclusion}
In conclusion, despite the steep learning curve associated with D3.js we think it will be the best option for our web application. It has the widest range of available graphs to accomodate all the client's requirments and desired visualizations. There are also a number of wrapper libraries available for D3.js like DC.js and dimple.js to help create charts from D3. This is a great way to get around the clunkiness and downsides to D3.js and reap the benefits of all the other charting libraries. Another benefit to using D3 is the extensive amount of templates, examples, and documentation that exists to help guide the process and implmentation of our application.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%% Authentication %%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Means of Incorporating Authentication}
Our web application will have an authentication layer which will allow users to register for our application and design their own ``stories.'' Our application will also authenticate user roles so that administrative users will have access to exclusive parts of the application. We want a simple way of authenticating users, while keeping personal information safe.
\subsection{Building Our Own Authentication Layer}
Node.js has a lot of helpful modules and packages that allow you to create your own password hashing functions and generate a custom authentication layer. There is a ``crypto'' module that is included in NodeJS that ``provides cryptographic functionality that includes a set of wrappers for OpenSSL's hash, HMAC, cipher, decipher, sign and verify functions''\cite{Crypto}. In addition to the crypto module, there are numerous NodeJS extension modules that perform different hashing functions and provide the same functionality as the native crypto module. There are modules like \href{https://www.npmjs.com/package/bcrypt-nodejs}{\textit{bcrypt}} and \href{https://www.npmjs.com/package/scrypt}{\textit{scrypt}} that use different hashing algorithms to salt and hash password into a fixed length string to be stored into the database.
\begin{lstlisting}[
    caption={[An example of how to salt hash passwords using the NodeJS crypto module]An example of how to salt hash passwords using the NodeJS crypto module (Taken from \href{https://ciphertrick.com/2016/01/18/salt-hash-passwords-using-nodejs-crypto/}{\textit{Rahil Shaikh's example}})\cite{Rahil_Shaikh}}
    ]
    'use strict';
    var crypto = require('crypto');
    /**
     * generates random string of characters i.e salt
     */
    var genRandomString = function(length){
        return crypto.randomBytes(Math.ceil(length/2))
                .toString('hex') /** convert to hexadecimal format */
                .slice(0,length);   /** return required number of characters */
    };
    /** hash password with sha512.
     * @function
     * @param {string} password - List of required fields.
     * @param {string} salt - Data to be validated.
     */
    var sha512 = function(password, salt){
        var hash = crypto.createHmac('sha512', salt); /** Hashing algorithm sha512 */
        hash.update(password);
        var value = hash.digest('hex');
        return {
            salt:salt,
            passwordHash:value
        };
    };
    function saltHashPassword(userpassword) {
        var salt = genRandomString(16); /** Gives us salt of length 16 */
        var passwordData = sha512(userpassword, salt);
        console.log('UserPassword = '+userpassword);
        console.log('Passwordhash = '+passwordData.passwordHash);
        console.log('nSalt = '+passwordData.salt);
    }
\end{lstlisting}
\textbf{Pros}
\begin{itemize}
    \item Creating our own authentication layer would provide us full control over how passwords are hashed and stored into the database. 
    \item Provide understanding of every component taht goes into our application's authentication.
    \item Do not have to rely on another API to authenticate users.
\end{itemize}
\textbf{Cons}
\begin{itemize}
    \item Laborious work and very time consuming.
    \item A lot of room for error and the possibility of data being compromised.
\end{itemize}
\subsection{Outsourcing Authentication to Google}
Google Authentication is widely used as means of 
\textbf{Pros}
\begin{itemize}
    \item Can provide multiple hash iterations to strengthen the security.
    \item Very secure hash that can hash the same password multiple times.
    \item Widely used today and remains unbroken.
    \item Vetted by the entire crypto community as it's now 15 years old \cite{medium}.
\end{itemize}
\textbf{Cons} 
\begin{itemize}
    \item Slow and computationally expensive hashing.
    \item Only used for password hashing, not a key-derivation function. 
\end{itemize}
\subsection{Use CAS (Central Authentication Service)}

\textbf{Pros}
\begin{itemize}
    \item Can provide multiple hash iterations to strengthen the security.
    \item Newly developed based on focusing on the issues with BCrypt and PBKDF2 involving constant memory.
\end{itemize}
\textbf{Cons}
\begin{itemize}
    \item New and not widely accepted by security/cryptographic professionals.
    \item Uses exponential time AND exponential memory which may be overkill for our application.
\end{itemize}
\subsection{Conclusion}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%% Front-end Framework %%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Front-end Framework}
Our web application will be a series of dashboards to display energy data based on different buildings and subsets of buildings on Oregon State University's campus. A key part to designing a clean dashboard is having a well-spaced grid-like layout with different charts and graphs to display a multitude of different datasets and trends. Rather than customizing classic html elements and using div containers to space our dashboard, we wanted to look into bootstrapped dashboard templates that allow easy customization and clean-looking results. 
\subsection{CSS Bootstrap}
\textit{Repository Commits: 17,255}\\ 
\textit{Contributors: 953}\\
CSS Bootstrap is the most widely used CSS framework available. It has the most expansive component list and helps developers create clean and beautiful UX/UI in minimal time frames. Bootstrap allows developers to get their paplications up and running quickly without having to worry about front-end styling. A major issue with Bootstrap is that it tends to look very similar across applications and leaves little room for simple customization.\\
\textbf{Pros}
\begin{itemize}
    \item Extensive component list, responsive design, and built-in Javascript functions.\cite{puranjay_2015}
    \item EFully responsive design.
    \item Huge developer contrbution and maintainence.
    \item Used by major companies like Lyft.com, Vogue.com, Vevo.com, and Newsweek.com. \cite{puranjay_2015}
\end{itemize}
\textbf{Cons}
\begin{itemize}
    \item Unsuitable for small scale projects. \cite{puranjay_2015}
    \item Not good if you want to have large control over UI.
\end{itemize}
\subsection{Pure CSS}
\textit{Repository Commits: 541}\\ 
\textit{Contributors: 51}\\
Pure CSS is known for its lightness and simplicity. Because it's small, it is very fast loading and makes for a lightweight web application. It is also unique in that it allows modules/components to be downloaded individually, reducing its size even more. Pure CSS is good for small projects that need to get up and running quickly and easily.\\
\textbf{Pros}
\begin{itemize}
    \item Meant for small project to get up and running quickly.
    \item Responsive design by default.
    \item Pure CSS is modular so you can download only the components you need.
    \item The complete module is very small so it is quick loading.
    \item Able to be used complimentary with other frameworks.
\end{itemize}
\textbf{Cons} 
\begin{itemize}
    \item Not as extensive component list as Bootstrap.
\end{itemize}
\subsection{Foundation}
\textit{Repository Commits: 15,094}\\ 
\textit{Contributors: 959}\\
Framework is the second most popular css framework on the market behind bootstrap and tends to perform just as well. Unlike bootstrap's very prominent theme, Foundation allows for more customization with the look and feel of web pages \cite{Nick_Pettit}. Foundation also has a very good grid system to make the layout of components clean and responsive \cite{blankenship_2017}.\\ 
\textbf{Pros}
\begin{itemize}
    \item Responsive design by default.
    \item Easier to customize than bootstrap.
    \item CSS classes are built in. \cite{team_2015}
    \item More unique look than the more-popular bootstrap.
    \item Good grid implementaions with customizable grid layouts.
\end{itemize}
\textbf{Cons}
\begin{itemize}
    \item Less maintained than bootstrap.
    \item Lack of support.
    \item Higher learning curve than bootstrap.
\end{itemize}
\subsection{Conclusion}
A lot of online resources acknowledged the fact that it is hard to make a website not look like bootstrap when using bootstrap css. Despite this, similar to our reasoning behind choosing D3.js, we would like to use a framework that is heavily supported and well-documented as it will be easier to answer questions during development. We think that the time spent restyling Bootstrap to make it look unique will not compare to the time saved by utilizing a well-documented framework. There is also a project called \href{https://angular-ui.github.io/bootstrap/}{UI Bootstrap} that works with AngularJS to create directives for each of the bootstrap components. \cite{sevilayha_2015}
\bibliographystyle{IEEEtran}
\bibliography{ref}
\end{document}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%% Old Section to Ignore %%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\iffalse
\section{Password Hashing Algorithms}
Our web application will have an authentication layer which will allow administrative users to have access to exclusive parts of the application. Anytime user information is stored into a database, it is important to hash the passwords and keep user credentials encrypted.
\subsection{PBKDF2}
The PBKDF2 algorithm is widely accepted as it is published by the RSA (RSA Security LLC). It provides a pseudorandom function and a salt value over many iteartion to create a derived key which is used in conjunction with a known key like a password to effectively hash that value into the database. It's many iterations make it difficult for hackers to break.
\textbf{Pros}
\begin{itemize}
    \item PBKDF2 allows for multiple iterations, and adding salted random input on any number of iterations \cite{jarmoc_2015}.
    \item RSA standard.    
\end{itemize}
\textbf{Cons}
\begin{itemize}
    \item Unsafe because PBKDF2 can be thoroughly optimized with GPU \cite{pornin_2012}.
    \item Complex API and slow computationally.
\end{itemize}
\subsection{Bcrypt}
The Bcrypt algorithm performs quite the same way as PBKDF2 except it makes use of table altering in its algorithm that highlights a fault in PBKDF2 where GPU's can break the encryption. Bcrypt has been around for a long time and is widely accepted as an ``unbreakable'' hashing method.\\
\textbf{Pros}
\begin{itemize}
    \item Can provide multiple hash iterations to strengthen the security.
    \item Very secure hash that can hash the same password multiple times.
    \item Widely used today and remains unbroken.
    \item Vetted by the entire crypto community as it’s now 15 years old \cite{medium}.
\end{itemize}
\textbf{Cons} 
\begin{itemize}
    \item Slow and computationally expensive hashing.
    \item Only used for password hashing, not a key-derivation function. 
\end{itemize}
\subsection{Scrypt}
Script works the same way as Bcrypt and PBKDF2 by iteratively hashing and using a salt value to create a hashed password. Scrypt is unique in that it take exponential memory to decypher the hash as well as exponential time for every iteration over the hashing algorithm which makes attackers even more unlikely to decypher passwords. Although Scrypt has been proven effective, it is still fairly new to the market and has not been totally varified.\\
\textbf{Pros}
\begin{itemize}
    \item Can provide multiple hash iterations to strengthen the security.
    \item Newly developed based on focusing on the issues with BCrypt and PBKDF2 involving constant memory.
\end{itemize}
\textbf{Cons}
\begin{itemize}
    \item New and not widely accepted by security/cryptographic professionals.
    \item Uses exponential time AND exponential memory which may be overkill for our application.
\end{itemize}
\subsection{Conclusion}
There is a lot of discussion and documentation involving password hashing algorithms and which ones are the ``safest.'' For our web application, we will not be handling sensitive user data like credit card information or personal information, so we do not need the most comprehansive and computationally heavy hashing algorithm to encrypt our user passwords. For this, it would be best to use BCrypt because it is so widely used, has proven to be secure, and easy to implement. BCrypt has its own npm library and can be easily configure to run on a Node.js environment. It also provides secure, salted hashed that can be iterated over a configurable amount to increase the hashes effectiveness.
\fi